<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curveware (HTB Business CTF 2025)</title>
    <link rel="stylesheet" href="/assets/css/obsidian-theme.css">
    <link rel="icon" type="image/png" href="/assets/images/favicon.png">
    <!-- MathJax configuration -->
    <script>
        window.MathJax = {
          tex: {
            packages: {'[+]': ['ams']},
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true,
            tags: 'ams',
            // Optional: Enable automatic equation numbering (if desired)
            // equationNumbers: { autoNumber: "AMS" }
          },
          options: {
            skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
          }
        };
      </script>
      <script id="MathJax-script" async
              src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
      </script>
      
  </head>
  <body class="theme-dark">
    <header>
      <!-- Optionally, show a site title -->
      <h1><a href="/", style="color: #ff5757;">Zukane CTF</a></h1>
    </header>
    <div class="container">
      <!-- Display post title from front matter -->
      
        <h2 class="post-title">Curveware (HTB Business CTF 2025)</h2>
      
      
        <div class="post-tags">
            
            <a href="/tags/elliptic-curve/" class="tag">Elliptic Curve</a>
            
            <a href="/tags/hidden-number-problem/" class="tag">Hidden Number Problem</a>
            
            <a href="/tags/ransomware/" class="tag">Ransomware</a>
            
            <a href="/tags/reverse-engineering/" class="tag">Reverse Engineering</a>
            
        </div>
      

      <!-- Main content -->
      <h5 id="challenge-overview">Challenge overview</h5>

<p>In this CTF challenge, we are given a set of encrypted files, and an elf binary:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>├── business-ctf-2025-dev
│   ├── crypto
│   │   ├── curveware
│   │   │   ├── flag.txt.vlny0742e9337a
│   │   │   ├── poc.py.vlnyc2b7865f66
│   │   │   ├── README.md.vlnya68395585b
│   │   │   └── task.txt.vlnyde7ca30df0
│   │   ├── early-bird
│   │   │   ├── flag.txt.vlny4a13aac40e
│   │   │   ├── README.md.vlny1d615936ca
│   │   │   └── task.txt.vlny152e012de7
│   │   ├── hidden-handshake
│   │   │   ├── flag.txt.vlny483931d01c
│   │   │   ├── README.md.vlnyda959133e7
│   │   │   └── task.txt.vlny37927847f9
│   │   ├── phoenix-zero-trust
│   │   │   ├── flag.txt.vlny42db696fd5
│   │   │   ├── README.md.vlnyd38f3522f4
│   │   │   └── task.txt.vlny383594e3ef
│   │   └── transcoded
│   │       ├── flag.txt.vlny048404e260
│   │       ├── README.md.vlnyd323bde76d
│   │       └── task.txt.vlnye5c611e15a
│   ├── README.md.vlny311cf84811
│   └── scenario.md.vlnycba760a47c
└── curveware

&gt; file curveware
curveware: PE32+ executable (console) x86-64, for MS Windows, 15 sections
</code></pre></div></div>

<p>This looks like a ransomware challenge. Based on the challenge title, it likely involves elliptic curves in some way. To find out what encryption has been used, and what cryptographic weakness can be used to decrypt the files, we have to reverse engineer the elf binary.</p>

<h5 id="reverse-engineering">Reverse engineering</h5>

<p>By disassembling the binary in Ghidra, we can get some insight into what encryption routine has been used on the files. The main function begins by calling the function <code class="language-plaintext highlighter-rouge">GetCurveParameters(local_9e8)</code></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">GetCurveParameters</span><span class="p">(</span><span class="n">undefined8</span> <span class="n">param_1</span><span class="p">){</span>
  <span class="kt">int</span> <span class="n">iVar1</span><span class="p">;</span>
  <span class="n">longlong</span> <span class="n">local_10</span><span class="p">;</span>
  
  <span class="n">iVar1</span> <span class="o">=</span> <span class="n">ec_get_curve_params_by_type</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="o">&amp;</span><span class="n">local_10</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">iVar1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">local_10</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">iVar1</span> <span class="o">=</span> <span class="n">import_params</span><span class="p">(</span><span class="n">param_1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iVar1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The function essentially just calls <code class="language-plaintext highlighter-rouge">ec_get_curve_params_by_type(4,&amp;local_10)</code> with curve type 4 and then instantiates the curve params with <code class="language-plaintext highlighter-rouge">import_params(param_1)</code>. One approach may be to investigate which elliptic curve corresponds to type 4 in a lookup table, but inspecting <code class="language-plaintext highlighter-rouge">ec_get_curve_params_by_type</code> reveals the curve in question:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">undefined8</span> <span class="nf">ec_get_curve_params_by_type</span><span class="p">(</span><span class="kt">int</span> <span class="n">param_1</span><span class="p">,</span><span class="n">undefined8</span> <span class="o">*</span><span class="n">param_2</span><span class="p">){</span>
  <span class="n">undefined8</span> <span class="n">uVar1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">local_c</span><span class="p">;</span>
  
  <span class="k">if</span> <span class="p">((</span><span class="n">param_1</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">param_2</span> <span class="o">!=</span> <span class="p">(</span><span class="n">undefined8</span> <span class="o">*</span><span class="p">)</span><span class="mh">0x0</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">uVar1</span> <span class="o">=</span> <span class="n">local_strlen</span><span class="p">(</span><span class="s">"SECP256R1"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">local_c</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">uVar1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">local_c</span> <span class="o">!=</span> <span class="mi">9</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mh">0xffffffff</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="o">*</span><span class="n">param_2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">secp256r1_str_params</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">uVar1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mh">0xffffffff</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So the program uses <code class="language-plaintext highlighter-rouge">secp256r1</code>, also known as <code class="language-plaintext highlighter-rouge">P-256</code>. We can retrieve the curve parameters from https://neuromancer.sk/std/secg/secp256r1 later. After loading the curve parameters, the main function generates a 32-byte random value <code class="language-plaintext highlighter-rouge">local_bc8</code> by calling <code class="language-plaintext highlighter-rouge">get_random(local_bc8,0x20)</code>. Afterwards, the program begins traversing the sub-directories and processes the files in <code class="language-plaintext highlighter-rouge">process_directory(pcVar5,lVar1,local_bc8,local_1578)</code>. Here, the 32-byte key <code class="language-plaintext highlighter-rouge">local_bc8</code> is passed as an argument. Also, the curve parameters <code class="language-plaintext highlighter-rouge">local_1578</code> are passed as well.</p>

<p><code class="language-plaintext highlighter-rouge">process_directory</code> is a recursive function which further traverses sub-directories, handling one directory at a time. The most notable parts of the function include:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">process_directory</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">param_1</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">param_2</span><span class="p">,</span><span class="n">undefined8</span> <span class="n">param_3</span><span class="p">,</span><span class="n">undefined8</span> <span class="o">*</span><span class="n">param_4</span><span class="p">){</span>
<span class="p">[...]</span>
	<span class="n">DVar3</span> <span class="o">=</span> <span class="n">GetFileSize</span><span class="p">(</span><span class="n">hFile</span><span class="p">,(</span><span class="n">LPDWORD</span><span class="p">)</span><span class="mh">0x0</span><span class="p">);</span>
	<span class="n">lpBuffer_00</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">((</span><span class="n">ulonglong</span><span class="p">)(</span><span class="n">DVar3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">BVar4</span> <span class="o">=</span> <span class="n">ReadFile</span><span class="p">(</span><span class="n">hFile</span><span class="p">,</span><span class="n">lpBuffer_00</span><span class="p">,</span><span class="n">DVar3</span><span class="p">,</span><span class="o">&amp;</span><span class="n">local_1e4</span><span class="p">,(</span><span class="n">LPOVERLAPPED</span><span class="p">)</span><span class="mh">0x0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">BVar4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">encrypt_data</span><span class="p">(</span><span class="n">lpBuffer_00</span><span class="p">,</span><span class="n">local_1e4</span><span class="p">,</span><span class="n">param_3</span><span class="p">,</span><span class="o">&amp;</span><span class="n">local_1d8</span><span class="p">,</span><span class="o">&amp;</span><span class="n">local_1dc</span><span class="p">,</span><span class="o">&amp;</span><span class="n">local_1d0</span><span class="p">);</span>
	<span class="n">lVar11</span> <span class="o">=</span> <span class="n">local_1d0</span><span class="p">;</span>
	<span class="n">lpBuffer</span> <span class="o">=</span> <span class="n">local_1d8</span><span class="p">;</span>
	<span class="n">DVar3</span> <span class="o">=</span> <span class="n">local_1dc</span><span class="p">;</span>
	<span class="n">sign_data</span><span class="p">(</span><span class="n">local_1c8</span><span class="p">,</span><span class="n">param_4</span><span class="p">,</span><span class="n">param_3</span><span class="p">,</span><span class="n">local_1d8</span><span class="p">,</span><span class="n">local_1dc</span><span class="p">,</span><span class="n">local_1d0</span><span class="p">);</span>
<span class="p">[...]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This section essentially reads in a file into the buffer <code class="language-plaintext highlighter-rouge">lpBuffer_00</code>, before calling the encryption routine <code class="language-plaintext highlighter-rouge">encrypt_data(lpBuffer_00,local_1e4,param_3,&amp;local_1d8,&amp;local_1dc,&amp;local_1d0)</code>. The variable <code class="language-plaintext highlighter-rouge">param_3</code> corresponds to the 32-byte key that was generated earlier. The encryption routine is as follows:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">encrypt_data</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">param_1</span><span class="p">,</span><span class="n">uint</span> <span class="n">param_2</span><span class="p">,</span><span class="n">undefined8</span> <span class="n">param_3</span><span class="p">,</span><span class="n">longlong</span> <span class="o">*</span><span class="n">param_4</span><span class="p">,</span><span class="n">uint</span> <span class="o">*</span><span class="n">param_5</span><span class="p">,</span> <span class="n">undefined8</span> <span class="o">*</span><span class="n">param_6</span><span class="p">){</span>
<span class="p">[...]</span>
  <span class="n">sha256</span><span class="p">(</span><span class="n">param_1</span><span class="p">,</span><span class="n">param_2</span><span class="p">);</span>
  <span class="n">uVar5</span> <span class="o">=</span> <span class="p">(</span><span class="n">ulonglong</span><span class="p">)</span><span class="n">param_2</span><span class="p">;</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="n">uVar4</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">uVar5</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="o">*</span><span class="n">param_4</span> <span class="o">+</span> <span class="n">uVar5</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">uVar6</span><span class="p">;</span>
    <span class="n">uVar5</span> <span class="o">=</span> <span class="p">(</span><span class="n">ulonglong</span><span class="p">)</span><span class="n">uVar4</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">uVar3</span> <span class="o">!=</span> <span class="n">uVar4</span><span class="p">);</span>
  <span class="n">get_random</span><span class="p">(</span><span class="o">&amp;</span><span class="n">local_158</span><span class="p">,</span><span class="mh">0x10</span><span class="p">);</span>
  <span class="n">AES_init_ctx_iv</span><span class="p">(</span><span class="n">local_148</span><span class="p">,</span><span class="n">param_3</span><span class="p">,</span><span class="o">&amp;</span><span class="n">local_158</span><span class="p">);</span>
  <span class="n">AES_CBC_encrypt_buffer</span><span class="p">(</span><span class="n">local_148</span><span class="p">,</span><span class="o">*</span><span class="n">param_4</span><span class="p">,</span><span class="o">*</span><span class="n">param_5</span><span class="p">);</span>
<span class="p">[...]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The plaintext <code class="language-plaintext highlighter-rouge">param_1</code> is hashed using SHA256. The hashed plaintext is saved into <code class="language-plaintext highlighter-rouge">param_6</code>. Then, a 16-byte random IV  is generated with <code class="language-plaintext highlighter-rouge">get_random(&amp;local_158,0x10)</code> and is passed to <code class="language-plaintext highlighter-rouge">AES_init_ctx_iv()</code> along with the 32-byte encryption key <code class="language-plaintext highlighter-rouge">param_3</code>. The plaintext is encrypted, and the IV is appended to the ciphertext before returning.</p>

<p>Back in the <code class="language-plaintext highlighter-rouge">process_directory</code> function, the ciphertext is signed with <code class="language-plaintext highlighter-rouge">sign_data(local_1c8,param_4,param_3,local_1d8,local_1dc,local_1d0)</code>. Crucially, the AES key <code class="language-plaintext highlighter-rouge">param_3</code> is passed to this function along with the ciphertext <code class="language-plaintext highlighter-rouge">local_1d8</code>, curve parameters <code class="language-plaintext highlighter-rouge">param_4</code> and plaintext hash <code class="language-plaintext highlighter-rouge">local_1d0</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">sign_data</span><span class="p">(</span><span class="n">longlong</span> <span class="n">param_1</span><span class="p">,</span><span class="n">longlong</span> <span class="n">param_2</span><span class="p">,</span><span class="n">undefined8</span> <span class="n">param_3</span><span class="p">,</span><span class="n">undefined8</span> <span class="n">param_4</span><span class="p">,</span> <span class="n">undefined4</span> <span class="n">param_5</span><span class="p">,</span><span class="n">undefined8</span> <span class="n">param_6</span><span class="p">){</span>
<span class="p">[...]</span>
  <span class="n">sha256</span><span class="p">(</span><span class="n">param_4</span><span class="p">,</span><span class="n">param_5</span><span class="p">,</span><span class="n">local_678</span><span class="p">);</span>
  <span class="n">nn_init_from_buf</span><span class="p">(</span><span class="n">local_428</span><span class="p">,</span><span class="n">local_678</span><span class="p">,</span><span class="mh">0x20</span><span class="p">);</span>
  <span class="n">nn_init_from_buf</span><span class="p">(</span><span class="n">local_578</span><span class="p">,</span><span class="n">param_3</span><span class="p">,</span><span class="mh">0x20</span><span class="p">);</span>
  <span class="n">nn_init_from_buf</span><span class="p">(</span><span class="n">local_5e8</span><span class="p">,</span><span class="n">param_6</span><span class="p">,</span><span class="mh">0x20</span><span class="p">);</span>
<span class="p">[...]</span>
  <span class="n">prj_pt_mul</span><span class="p">(</span><span class="n">local_1c8</span><span class="p">,</span><span class="n">local_5e8</span><span class="p">,</span><span class="n">param_2</span> <span class="o">+</span> <span class="mh">0x560</span><span class="p">);</span>
  <span class="n">prj_pt_to_aff</span><span class="p">(</span><span class="n">local_2d8</span><span class="p">,</span><span class="n">local_1c8</span><span class="p">);</span>
  <span class="n">nn_mod_sub</span><span class="p">(</span><span class="n">local_3b8</span><span class="p">,</span><span class="n">local_428</span><span class="p">,</span><span class="n">local_2d8</span><span class="p">,</span><span class="o">&amp;</span><span class="n">local_658</span><span class="p">);</span>
  <span class="n">nn_modinv_fermat</span><span class="p">(</span><span class="n">local_508</span><span class="p">,</span><span class="n">local_578</span><span class="p">,</span><span class="o">&amp;</span><span class="n">local_658</span><span class="p">);</span>
  <span class="n">nn_mod_sub</span><span class="p">(</span><span class="n">local_498</span><span class="p">,</span><span class="n">local_5e8</span><span class="p">,</span><span class="n">local_3b8</span><span class="p">,</span><span class="o">&amp;</span><span class="n">local_658</span><span class="p">);</span>
  <span class="n">nn_mod_mul</span><span class="p">(</span><span class="n">local_348</span><span class="p">,</span><span class="n">local_508</span><span class="p">,</span><span class="n">local_498</span><span class="p">,</span><span class="o">&amp;</span><span class="n">local_658</span><span class="p">);</span>
  <span class="n">nn_export_to_buf</span><span class="p">(</span><span class="n">param_1</span><span class="p">,</span><span class="mh">0x20</span><span class="p">,</span><span class="n">local_3b8</span><span class="p">);</span>
  <span class="n">nn_export_to_buf</span><span class="p">(</span><span class="n">param_1</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">,</span><span class="mh">0x20</span><span class="p">,</span><span class="n">local_348</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This signing routine essentially performs a series of computations like follows:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">sha256(param_4,param_5,local_678)</code> is the SHA256 of the ciphertext</li>
  <li><code class="language-plaintext highlighter-rouge">nn_init_from_buf(local_428,local_678,0x20)</code> loads the ciphertext hash $z$ to <code class="language-plaintext highlighter-rouge">local_428</code></li>
  <li><code class="language-plaintext highlighter-rouge">nn_init_from_buf(local_578,param_3,0x20)</code> loads the AES key $d$ to <code class="language-plaintext highlighter-rouge">local_578</code></li>
  <li><code class="language-plaintext highlighter-rouge">nn_init_from_buf(local_5e8,param_6,0x20)</code> loads the nonce $k$ (plaintext hash) to <code class="language-plaintext highlighter-rouge">local_5e8</code></li>
  <li><code class="language-plaintext highlighter-rouge">prj_pt_mul(local_1c8,local_5e8,param_2 + 0x560)</code> calculates $R = k \cdot G$</li>
  <li><code class="language-plaintext highlighter-rouge">prj_pt_to_aff(local_2d8,local_1c8)</code> gets the affine coordinate $R.x$</li>
  <li><code class="language-plaintext highlighter-rouge">nn_mod_sub(local_3b8,local_428,local_2d8,&amp;local_658)</code> calculates $r = (z - R.x) \mod n$</li>
  <li><code class="language-plaintext highlighter-rouge">nn_modinv_fermat(local_508,local_578,&amp;local_658)</code> calculates $d^{-1} \mod n$</li>
  <li><code class="language-plaintext highlighter-rouge">nn_mod_sub(local_498,local_5e8,local_3b8,&amp;local_658)</code> calculates $k - r \mod n$</li>
  <li><code class="language-plaintext highlighter-rouge">nn_mod_mul(local_348,local_508,local_498,&amp;local_658)</code> calculates $s = (k-r)\cdot d^{-1} \mod n$</li>
</ul>

<p>Where $n$ is the curve order of <code class="language-plaintext highlighter-rouge">secp256r1</code>. The signature, consisting of values $(r,s)$, are returned by the function. The signing process looks similar to ECDSA, but it is not the same. We have $k = r+sd$ while ECDSA uses $k = s^{-1}(z+rd)$</p>

<p>Returning to <code class="language-plaintext highlighter-rouge">process_directory</code>, the function does some final crucial steps:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">*</span><span class="n">_Memory</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">undefined4</span> <span class="o">*</span><span class="p">)(</span><span class="n">lVar11</span> <span class="o">+</span> <span class="mh">0x1b</span><span class="p">);</span>
<span class="o">*</span><span class="p">(</span><span class="n">undefined1</span> <span class="o">*</span><span class="p">)(</span><span class="n">_Memory</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">undefined1</span> <span class="o">*</span><span class="p">)(</span><span class="n">lVar11</span> <span class="o">+</span> <span class="mh">0x1f</span><span class="p">);</span>
<span class="n">_Source</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mh">0xb</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">puVar12</span> <span class="o">=</span> <span class="n">_Memory</span><span class="p">;</span>
<span class="n">pcVar10</span> <span class="o">=</span> <span class="n">_Source</span><span class="p">;</span>
<span class="k">do</span> <span class="p">{</span>
	<span class="n">uVar1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">undefined1</span> <span class="o">*</span><span class="p">)</span><span class="n">puVar12</span><span class="p">;</span>
	<span class="n">pcVar15</span> <span class="o">=</span> <span class="n">pcVar10</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">puVar12</span> <span class="o">=</span> <span class="p">(</span><span class="n">undefined4</span> <span class="o">*</span><span class="p">)((</span><span class="n">longlong</span><span class="p">)</span><span class="n">puVar12</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">__mingw_snprintf</span><span class="p">(</span><span class="n">pcVar10</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">&amp;</span><span class="p">.</span><span class="n">rdata</span><span class="p">,</span><span class="n">uVar1</span><span class="p">);</span>
	<span class="n">pcVar10</span> <span class="o">=</span> <span class="n">pcVar15</span><span class="p">;</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">pcVar15</span> <span class="o">!=</span> <span class="n">_Source</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">DVar5</span> <span class="o">=</span> <span class="n">SetFilePointer</span><span class="p">(</span><span class="n">hFile</span><span class="p">,</span><span class="mi">0</span><span class="p">,(</span><span class="n">PLONG</span><span class="p">)</span><span class="mh">0x0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">BVar4</span> <span class="o">=</span> <span class="n">WriteFile</span><span class="p">(</span><span class="n">hFile</span><span class="p">,</span><span class="n">local_1c8</span><span class="p">,</span><span class="mh">0x40</span><span class="p">,</span><span class="o">&amp;</span><span class="n">local_1e0</span><span class="p">,(</span><span class="n">LPOVERLAPPED</span><span class="p">)</span><span class="mh">0x0</span><span class="p">);</span>
<span class="n">BVar4</span> <span class="o">=</span> <span class="n">WriteFile</span><span class="p">(</span><span class="n">hFile</span><span class="p">,</span><span class="n">lpBuffer</span><span class="p">,</span><span class="n">DVar3</span><span class="p">,</span><span class="o">&amp;</span><span class="n">local_1e0</span><span class="p">,(</span><span class="n">LPOVERLAPPED</span><span class="p">)</span><span class="mh">0x0</span><span class="p">);</span>
<span class="n">CloseHandle</span><span class="p">(</span><span class="n">hFile</span><span class="p">);</span>
<span class="n">pcVar10</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="n">lVar8</span> <span class="o">+</span> <span class="mh">0x11</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">strncpy</span><span class="p">(</span><span class="n">pcVar10</span><span class="p">,</span><span class="n">pcVar7</span><span class="p">,</span><span class="n">lVar8</span> <span class="o">+</span> <span class="mi">1U</span><span class="p">);</span>
<span class="n">sVar6</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">pcVar10</span><span class="p">);</span>
<span class="n">builtin_strncpy</span><span class="p">(</span><span class="n">pcVar10</span> <span class="o">+</span> <span class="n">sVar6</span><span class="p">,</span><span class="s">".vlny"</span><span class="p">,</span><span class="mi">6</span><span class="p">);</span>
<span class="n">strncat</span><span class="p">(</span><span class="n">pcVar10</span><span class="p">,</span><span class="n">_Source</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
<span class="n">BVar4</span> <span class="o">=</span> <span class="n">MoveFileA</span><span class="p">(</span><span class="n">pcVar7</span><span class="p">,</span><span class="n">pcVar10</span><span class="p">);</span> 
</code></pre></div></div>

<p>This part essentially appends the suffix <code class="language-plaintext highlighter-rouge">.vlny</code> to the encrypted file’s filename, followed by 10 hex digits (5 bytes) of the plaintext hash. This is a critical part, as the plaintext hash is used as the nonce during the signing process, meaning we have a partial nonce leak for every signature. The 5 bytes correspond to the 40 least significant bits. This final part also writes the encrypted file contents, consisting of the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>signing variable s (32 bytes)
signing variable r (32 bytes)
ciphertext 
IV (16 bytes)
</code></pre></div></div>

<h5 id="decrypting-files">Decrypting files</h5>

<p>With a solid overview over the encryption process, signing process, and the file structure, the cryptographic vulnerability becomes quite apparent. 40/256 bits are leaked for all 18 signatures, allowing for the recovery of the private key $d$ by setting up and solving a hidden number problem instance. Since the private key $d$ is used for both signing and AES encryption, recovering the original plaintext file contents becomes trivial.</p>

<p>Like mentioned earlier, the custom signing algorithm uses the equation:</p>

\[\large k = r + s\cdot d\]

<p>Since we have a partial leak of the nonce, we can rewrite to:</p>

\[\large \begin{align}
\nonumber leak + 2^{40} \cdot x &amp;\equiv r + s \cdot d \mod n\\
\nonumber s \cdot d - 2^{40}\cdot x &amp;\equiv leak - r \mod n \\
\nonumber 2^{40^{-1}} \cdot s \cdot d - x &amp;\equiv 2^{40^{-1}}(leak - r) \mod n \\
\nonumber x - 2^{40^{-1}}\cdot s\cdot d+2^{40^{-1}}(leak-r) &amp;\equiv 0 \mod n
\end{align}\]

<p>Which is precisely a hidden number problem instance: $\beta_{i} - t_{i} \cdot \alpha + a_{i} \equiv 0 \mod p$ with $t = 2^{40^{-1}}\cdot s$ and $a = 2^{40^{-1}}(leak-r)$</p>

<p>The private key $d$ can be recovered by running LLL on the following lattice:</p>

\[\large B' = \begin{bmatrix}
n &amp;  &amp;  &amp;  &amp;  &amp; \\
 &amp; n &amp;  &amp;  &amp;  &amp; \\
 &amp;  &amp; \ddots &amp;  &amp;  &amp; \\
 &amp;  &amp;  &amp; n &amp;  &amp; \\
t_{1} &amp; t_{2} &amp; \dots &amp; t_{m} &amp; 2^{40}/n  \\
a_{1} &amp; a_{2} &amp; \dots &amp; a_{m} &amp;  &amp; 2^{40}
\end{bmatrix}\]

<p>With short vector $\large u’ = (x_{1},\dots,x_{m},2^{40}d/n,-2^{40})$</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">M</span> <span class="o">=</span> <span class="n">identity_matrix</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="n">n</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">stack</span><span class="p">(</span><span class="n">vector</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">stack</span><span class="p">(</span><span class="n">vector</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">augment</span><span class="p">(</span><span class="n">vector</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="p">[</span><span class="n">B</span><span class="o">/</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">augment</span><span class="p">(</span><span class="n">vector</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span>   <span class="n">B</span><span class="p">]))</span>

<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">M</span><span class="p">.</span><span class="n">LLL</span><span class="p">():</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">B</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="n">B</span> <span class="o">%</span> <span class="n">n</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"d = </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="k">break</span>
<span class="c1"># d = 0xc5120eda0305ce74a125b5bd727e4fee5a24457ab376b69578c179f8440881e0
</span></code></pre></div></div>

<p>With the private key recovered, the <code class="language-plaintext highlighter-rouge">flag.txt.vlny0742e9337a</code> file can be decrypted, giving us our flag!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTB{m4lw4r3_d3v3l0p3rs_sh0uld_sTuDy_m0r3_crypt0}
</code></pre></div></div>

<h5 id="solvesage">solve.sage</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">Crypto.Cipher</span> <span class="kn">import</span> <span class="n">AES</span>
<span class="kn">from</span> <span class="nn">Crypto.Util.Padding</span> <span class="kn">import</span> <span class="n">unpad</span>
<span class="kn">from</span> <span class="nn">Crypto.Util.number</span> <span class="kn">import</span> <span class="n">bytes_to_long</span><span class="p">,</span> <span class="n">long_to_bytes</span>

<span class="n">n</span> <span class="o">=</span> <span class="mh">0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551</span>
<span class="n">B</span> <span class="o">=</span> <span class="mi">2</span><span class="o">^</span><span class="mi">40</span>     
<span class="n">Binv</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>                   

<span class="n">root</span>  <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s">'business-ctf-2025-dev'</span><span class="p">)</span>
<span class="n">files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">rglob</span><span class="p">(</span><span class="s">'*.vlny*'</span><span class="p">))</span>

<span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">leak</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
    <span class="n">blob</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read_bytes</span><span class="p">()</span>
    <span class="n">r</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">bytes_to_long</span><span class="p">(</span><span class="n">blob</span><span class="p">[</span>  <span class="p">:</span><span class="mi">32</span><span class="p">]))</span>
    <span class="n">s</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">bytes_to_long</span><span class="p">(</span><span class="n">blob</span><span class="p">[</span><span class="mi">32</span><span class="p">:</span><span class="mi">64</span><span class="p">]))</span>
    <span class="n">leak</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">suffix</span><span class="p">[</span><span class="mi">5</span><span class="p">:],</span> <span class="mi">16</span><span class="p">))</span>

<span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">ri</span><span class="p">,</span> <span class="n">si</span><span class="p">,</span> <span class="n">li</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">leak</span><span class="p">):</span>
    <span class="n">t</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">Binv</span> <span class="o">*</span> <span class="n">si</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">a</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="o">-</span><span class="n">Binv</span> <span class="o">*</span> <span class="p">(</span><span class="n">li</span> <span class="o">-</span> <span class="n">ri</span><span class="p">))</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>

<span class="n">M</span> <span class="o">=</span> <span class="n">identity_matrix</span><span class="p">(</span><span class="n">QQ</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="n">n</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">stack</span><span class="p">(</span><span class="n">vector</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">stack</span><span class="p">(</span><span class="n">vector</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">augment</span><span class="p">(</span><span class="n">vector</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="p">[</span><span class="n">B</span><span class="o">/</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="p">.</span><span class="n">augment</span><span class="p">(</span><span class="n">vector</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span>   <span class="n">B</span><span class="p">]))</span>

<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">M</span><span class="p">.</span><span class="n">LLL</span><span class="p">():</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">B</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="n">B</span> <span class="o">%</span> <span class="n">n</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"d = </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="k">break</span>

<span class="n">key</span> <span class="o">=</span> <span class="n">long_to_bytes</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">files</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># curvewave flagfile
</span><span class="n">blob</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read_bytes</span><span class="p">()</span>
<span class="n">ct</span>  <span class="o">=</span> <span class="n">blob</span><span class="p">[</span><span class="mi">64</span><span class="p">:]</span>          
<span class="n">iv</span>  <span class="o">=</span> <span class="n">ct</span><span class="p">[</span><span class="o">-</span><span class="mi">16</span><span class="p">:]</span>
<span class="n">aes</span> <span class="o">=</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_CBC</span><span class="p">,</span> <span class="n">iv</span><span class="p">)</span>
<span class="n">pt</span>  <span class="o">=</span> <span class="n">unpad</span><span class="p">(</span><span class="n">aes</span><span class="p">.</span><span class="n">decrypt</span><span class="p">(</span><span class="n">ct</span><span class="p">[:</span><span class="o">-</span><span class="mi">16</span><span class="p">]),</span> <span class="mi">16</span><span class="p">).</span><span class="n">decode</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>   
</code></pre></div></div>

    </div>
    <footer>
      <p>&copy; 2025 Zukane</p>
    </footer>
  </body>
</html>
